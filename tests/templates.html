<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<script src="../vivy.js"></script>
	<script src="./test_utils.js"></script>
	<style>
		.test-case { border: 1px solid #ccc; padding: 10px; margin: 10px 0; }
	</style>
</head>
<body>
	<h1>Template Binding Tests</h1>

	<!-- Basic Template -->
	<div id="template-basic-test" class="test-case">
		<h3>1. Basic Template</h3>
		<div class="original">
			<p :template="original">
				original <span .text></span>
			</p>
			<t:original></t:original>
		</div>

		<div class="nested">
			<p :template="nested">
				<span>nested</span>
				<t:disappearing></t:disappearing>
			</p>
			<t:nested></t:nested>
			<vivy:template name="disappearing">
				hi <span .text></span>
			</vivy:template>
		</div>
	</div>
	<script>
	runTest("Basic Template", document.getElementById("template-basic-test"), async (el) => {
		const app = vivy(el, { text: "text" });

		const originalSpans = Array.from(el.querySelectorAll(".original p span"));
		const nestedSpans = Array.from(el.querySelectorAll(".nested p span"));

		// Original content + instantiated template
		assert(originalSpans.length === 2, "Original Spans Count");
		assert(originalSpans[0].textContent === "text", "Original Content");
		assert(originalSpans[1].textContent === "text", "Template Content");

		// Nested
		// "nested" (literal), "hi text" (from disappearing), duplicated
		// nestedSpans = [span(nested), span(text), span(nested), span(text)]
		assert(nestedSpans.length === 4, "Nested Spans Count");
		assert(nestedSpans[1].textContent === "text", "Nested Template Content");
		assert(nestedSpans[3].textContent === "text", "Nested Instance Content");

		app.text = "text too";
		assert(originalSpans[0].textContent === "text too", "Update Original");
		assert(originalSpans[1].textContent === "text too", "Update Instance");
	});
	</script>

	<!-- Error Scenarios -->
	<div id="error-scenario-tests" class="test-case">
		<h3>2. Error Scenarios</h3>
		<div id="tmpl-missing-name">
			<vivy:template></vivy:template>
		</div>
		<div id="tmpl-duplicate">
			<vivy:template name="dup"></vivy:template>
			<vivy:template name="dup"></vivy:template>
		</div>
		<div id="tmpl-unknown">
			<t:unknown></t:unknown>
		</div>
		<div id="tmpl-recursion">
			<t:recurse></t:recurse>
			<vivy:template name="recurse">
				<t:recurse></t:recurse>
			</vivy:template>
		</div>
	</div>
	<script>
	runTest("Error Scenarios - Template Definition", document.getElementById("error-scenario-tests"), async (el) => {
		// Missing name
		let err = null;
		try {
			vivy(el.querySelector("#tmpl-missing-name"), {});
		} catch (e) { err = e; }
		assert(err?.message.includes("Template missing name"), "Detects missing template name");

		// Duplicate name
		err = null;
		try {
			vivy(el.querySelector("#tmpl-duplicate"), {});
		} catch (e) { err = e; }
		assert(err?.message.includes("Duplicate template name"), "Detects duplicate template");

		// Unknown template
		err = null;
		try {
			vivy(el.querySelector("#tmpl-unknown"), {});
		} catch (e) { err = e; }
		assert(err?.message.includes("Unknown template"), "Detects unknown template ref");

		// Infinite Recursion (Loop limit)
		err = null;
		try {
			vivy(el.querySelector("#tmpl-recursion"), {});
		} catch (e) { err = e; }
		assert(err?.message.includes("possible infinite loop"), "Detects infinite template recursion");
	});
	</script>

	<!-- Recursive Template -->
	<div id="template-tree-test" class="test-case">
		<h3>3. Recursive Template (Tree)</h3>
		<ul>
			<li :template="tree">
				<span .name @dblclick="$.add_child"></span>
				<button @click="$.add_child">+</button>
				<ul .children.length?>
					<t:tree .children[]></t:tree>
				</ul>
			</li>
		</ul>
	</div>
	<script>
	runTest("Recursive Template", document.getElementById("template-tree-test"), async (el) => {
		const app = vivy(el, {
			name: "root",
			children: [],
			add_child: (_event, node) => node.children.push({
				name: `child${node.children.length + 1}`, children: []
			})
		});

		const getSpans = () => Array.from(el.querySelectorAll("span")).map(s => s.textContent);

		assert(getSpans().join(",") === "root", "Init Root");

		const rootBtn = el.querySelector("button");
		if (!rootBtn) throw new Error(`Root button not found in: ${el.innerHTML}`);
		rootBtn.dispatchEvent(new Event("click"));

		await wait(50); // Increased wait time

		const buttons = el.querySelectorAll("button");
		if (buttons.length < 2) {
			 console.error(`DEBUG Templates Recursive Fail. HTML: ${el.innerHTML}`);
			 throw new Error(`Expected at least 2 buttons, found ${buttons.length}`);
		}
		const child1Btn = buttons[1];
		child1Btn.dispatchEvent(new Event("click"));
		await wait(20);

		assert(getSpans().join(",") === "root,child1,child1", "Add Nested Child");

		assert(app.children.length === 1, "Root has 1 child");
		assert(app.children[0].name === "child1", "Child1 Name");
		assert(app.children[0].children.length === 1, "Child1 has 1 child");
	});
	</script>

	<!-- Template Scope -->
	<div id="template-scope-test" class="test-case">
		<h3>4. Template Scope</h3>
		<t:embed .info></t:embed>
		<vivy:template name="embed">
			Hello <span .name></span>
		</vivy:template>
	</div>
	<script>
	runTest("Template Scope", document.getElementById("template-scope-test"), async (el) => {
		const app = vivy(el, { info: { name: "emery" } });
		const span = el.querySelector("span");

		assert(span.textContent === "emery", "Init Scope");

		app.info.name = "bob";
		assert(span.textContent === "bob", "Update Scope");
	});
	</script>

	<!-- Shared State Bug (excessive templates) -->
	<div id="shared-state-test" class="test-case">
		<h3>5. Shared State Bug (Excessive Templates)</h3>
		<p>Checking if template usage limits or shared state cause issues across instances.</p>
		<div id="app1">
			<vivy:template name="t">x</vivy:template>
			<div id="container1"></div>
		</div>
		<div id="app2">
			<vivy:template name="t">x</vivy:template>
			<div id="container2"></div>
		</div>
	</div>
	<script>
	runTest("Shared State Bug", document.getElementById("shared-state-test"), async (testRoot) => {
		const container1 = testRoot.querySelector('#container1');
		const container2 = testRoot.querySelector('#container2');

		// Generate many template usages
		const count = 6000;
		const html = Array(count).fill('<t:t></t:t>').join('');
		container1.innerHTML = html;
		container2.innerHTML = html;

		console.log("Initializing App 1...");
		vivy(testRoot.querySelector('#app1'), {});
		console.log("App 1 initialized.");

		console.log("Initializing App 2...");
		vivy(testRoot.querySelector('#app2'), {});
		console.log("App 2 initialized.");

		// If we got here without error, it passed.
		// We can assert content length to be sure it rendered.
		assert(container1.textContent.length === count, "App 1 Rendered correctness");
		assert(container2.textContent.length === count, "App 2 Rendered correctness");
	});
	</script>
	<!-- Template Null Scope -->
	<div id="template-null-scope-test" class="test-case">
		<h3>6. Template Null Scope</h3>
		<div .parent :show-if=".">
			<t:embed-null .info :show-if="."></t:embed-null>
		</div>
		<vivy:template name="embed-null">
			<div>Hello <span .name></span></div>
		</vivy:template>
	</div>
	<script>
	runTest("Template Null Scope", document.getElementById("template-null-scope-test"), async (el) => {
		const app = vivy(el, { parent: null });

		assert(el.querySelector("div span") === null, "Init Null (Hidden)");

		app.parent = { info: { name: "emery" } };
		const span = el.querySelector("span");
		assert(span && span.textContent === "emery", "Update to valid scope");
	});
	</script>

	<!-- Template Nested Scope -->
	<div id="template-nested-scope-test" class="test-case">
		<h3>7. Template Nested Scope</h3>
		<div .parent>
			<t:embed1 .info :show-if="."></t:embed1>
		</div>
		<vivy:template name="embed1">
			<div .nested>
				Hello <span .name></span>
			</div>
		</vivy:template>
	</div>
	<script>
	runTest("Template Nested Scope", document.getElementById("template-nested-scope-test"), async (el) => {
		const app = vivy(el, { parent: null });

		assert(el.querySelector("span") === null, "Init Null");

		app.parent = { info: { nested: { name: "emery" } } };
		// Template binds .info.
		// Inside: <div .nested> -> sub-scope `nested`.
		// Inside: <span .name> -> `name`.
		// So info needs correct structure.
		// app.parent = { info: ... }
		// .info = { nested: { name: "emery" } }

		await wait(10);
		const span = el.querySelector("span");
		assert(span && span.textContent === "emery", "Deep Nested Scope");
	});
	</script>

	<!-- Template Root Access in Loop -->
	<div id="template-root-loop" class="test-case">
		<h3>8. Template Root Access in Loop</h3>
		<vivy:template name="item-with-root">
			<li>
				<span class="item-text" .text></span>
				<span class="global-label" $.label></span>
			</li>
		</vivy:template>
		<ul .items[]>
			<t:item-with-root></t:item-with-root>
		</ul>
	</div>
	<script>
	runTest("Template Root Access in Loop", document.getElementById("template-root-loop"), async (el) => {
		const app = vivy(el, {
			label: "Global",
			items: [
				{ text: "Item 1" },
				{ text: "Item 2" },
				{ text: "Item 3" }
			]
		});

		const itemTexts = Array.from(el.querySelectorAll('.item-text')).map(s => s.textContent);
		const globalLabels = Array.from(el.querySelectorAll('.global-label')).map(s => s.textContent);

		assert(itemTexts.join(',') === "Item 1,Item 2,Item 3", "Item texts correct");
		assert(globalLabels.join(',') === "Global,Global,Global", "All labels show root value");

		// Update root label
		app.label = "Updated Global";
		const updatedLabels = Array.from(el.querySelectorAll('.global-label')).map(s => s.textContent);
		assert(updatedLabels.join(',') === "Updated Global,Updated Global,Updated Global", "Root update reflects in all items");

		// Update individual item
		app.items[1].text = "Modified Item 2";
		const newTexts = Array.from(el.querySelectorAll('.item-text')).map(s => s.textContent);
		assert(newTexts[1] === "Modified Item 2", "Individual item update works");
	});
	</script>

	<!-- Template Referencing Another Template -->
	<div id="template-ref-template" class="test-case">
		<h3>9. Template Referencing Another Template</h3>
		<vivy:template name="inner-template">
			<span class="inner" .value></span>
		</vivy:template>
		<vivy:template name="outer-template">
			<div class="outer">
				<strong .label></strong>
				<t:inner-template .data></t:inner-template>
			</div>
		</vivy:template>
		<t:outer-template></t:outer-template>
	</div>
	<script>
	runTest("Template Referencing Another Template", document.getElementById("template-ref-template"), async (el) => {
		const app = vivy(el, {
			label: "Outer Label",
			data: { value: "Inner Value" }
		});

		const label = el.querySelector('strong');
		const inner = el.querySelector('.inner');

		assert(label.textContent === "Outer Label", "Outer template rendered");
		assert(inner.textContent === "Inner Value", "Nested template rendered");

		// Update outer
		app.label = "New Label";
		assert(label.textContent === "New Label", "Outer update");

		// Update inner
		app.data.value = "New Inner";
		assert(inner.textContent === "New Inner", "Inner update");

		// Replace data object
		app.data = { value: "Replaced" };
		assert(inner.textContent === "Replaced", "Inner replacement");
	});
	</script>

	<!-- Template with Method Calls -->
	<div id="template-method-calls" class="test-case">
		<h3>10. Template Method Calls in Attribute Templates</h3>
		<vivy:template name="formatted-item">
			<div class="item-box">
				<span class="formatted" data-upper.="`${_.text?.toUpperCase()}`"></span>
				<span class="length" data-len.="`${_.text?.length}`"></span>
			</div>
		</vivy:template>
		<div .items[]>
			<t:formatted-item></t:formatted-item>
		</div>
	</div>
	<script>
	runTest("Template Method Calls", document.getElementById("template-method-calls"), async (el) => {
		const app = vivy(el, {
			items: [
				{ text: "hello" },
				{ text: "world" }
			]
		});

		const uppers = Array.from(el.querySelectorAll('.formatted')).map(s => s.getAttribute('data-upper'));
		const lengths = Array.from(el.querySelectorAll('.length')).map(s => s.getAttribute('data-len'));

		assert(uppers.join(',') === "HELLO,WORLD", "toUpperCase() works in template");
		assert(lengths.join(',') === "5,5", "length property works in template");

		// Update item
		app.items[0].text = "updated";
		await wait(10);
		const newUppers = Array.from(el.querySelectorAll('.formatted')).map(s => s.getAttribute('data-upper'));
		assert(newUppers[0] === "UPDATED", "Method call updates");
	});
	</script>

	<!-- Scope with Templates -->
	<div id="template-scope-complex" class="test-case">
		<h3>11. Scope with Templates</h3>
		<div .user>
			<t:user-card .details></t:user-card>
		</div>
		<vivy:template name="user-card">
			<div class="card">
				<span class="name" .name></span>
				<span class="role" $.role></span>
			</div>
		</vivy:template>
	</div>
	<script>
	runTest("Scope with Templates", document.getElementById("template-scope-complex"), async (el) => {
		const app = vivy(el, {
			role: "admin",
			user: {
				details: {
					name: "bob"
				}
			}
		});

		const name = el.querySelector(".name");
		const role = el.querySelector(".role");

		assert(name.textContent === "bob", "Name from nested scope");
		assert(role.textContent === "admin", "Role from root scope");

		app.user.details.name = "alice";
		assert(name.textContent === "alice", "Update nested scope");

		app.role = "super-admin";
		assert(role.textContent === "super-admin", "Update root scope");
	});
	</script>

	<!-- Circular Reference with Recursive Template Test -->
	<div id="circular-ref-test" class="test-case">
		<h3>12. Circular Reference with Recursive Template</h3>
			<t:recursive-template .obj></t:recursive-template>
			<vivy:template name="recursive-template">
				<t:recursive-template .self></t:recursive-template>
		</vivy:template>
	</div>
	<script>
	runTest("Circular Reference with Recursive Template", document.getElementById("circular-ref-test"), async (el) => {
		const obj = {};
		obj.self = obj; // Circular ref

		let err;
		try { vivy(el, { obj }); } catch (e) { err = e; }
		assert(err.message.includes("infinite loop"), `Infinite loop not detected: ${err.message}`);
	});
	</script>

	<!-- Template with Only Text Nodes -->
	<div id="template-text-only-test" class="test-case">
		<h3>13. Template with Only Text Nodes</h3>
		<vivy:template name="text-only">Just text, no elements</vivy:template>
		<t:text-only></t:text-only>
	</div>
	<script>
	runTest("Template with Only Text Nodes", document.getElementById("template-text-only-test"), async (el) => {
		vivy(el, {});

		const text = el.textContent;
		assert(text.includes("Just text"), `Text-only template rendered: ${text}`);
	});
	</script>

</body>
</html>
